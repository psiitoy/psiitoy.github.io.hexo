---
layout: post
title: "[总结]actor总结"
date: 2016-07-25 21:15:06 
categories: 
    - 总结
tags:
    - actor
---

[总结]actor总结

<!--more-->

相对整个系统的并发，actor 就是 “局部串行”，mailbox 里面的 messages 都是顺序执行的。“解决并发问题的唯一手段是局部串行”，你要 “局部串行” ？怎么弄 ？最终还得用锁。


其实就是抽象的层度不同而已，juc和akka都是无锁抽象，不过akka抽象程度更高而已，然后 akka 底层用的也是 forkjoin

也可以把 actor 看作 “局部串行” 的延伸，只不过 actor 加了点东西，形成了自己的理论。actor 说白了，就是状态加逻辑的一个实体，然后这个实体在 erlang、 akka 中被视为不可分割的原子单元，然后这个单元在运行时*串行*的对外提供服务，这样的话这个单元内部是没有并发的。这不就是 “局部串行” 吗 ？

只要msg是immutable的话，就可以不用串行


如果从纯理论的角度，actor可以默认我有消息队列的机制。但除非从硬件层就是这样的机制，否则这种同步队列mailbox必然用到锁（或者进一步，硬件锁也是锁啊），这就是局部串行啊，unix里也有pipe啊。换句话说，我觉得actor就是造出来的用来圈钱攒paper的概念，新瓶装旧酒而已，不用太在意。



管理器对 actor 说：不要找我；我会去找您。


函数式编程前段时间很火，但是纯FP的语言逐渐被对象和函数混合式的语言如Scala赶超，关键还是可变的状态是现实中无法回避的问题，可变的使用对象式的Actror是最合适的，而不变性使用函数这种机器处理方式也是最合适的。可变性对应写操作，不变性对应读操作，如大数据处理，报表BI等。
Actor前提是事务+高并发